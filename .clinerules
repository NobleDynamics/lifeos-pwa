# LifeOS Project Rules & Context

## 1. Design System & Components (The "DRY" Law)
* **Check First:** Before building *any* UI, check `src/components/shared/` and `src/components/ui/`.
* **Extend, Don't Duplicate:** If a component is close to what you need, add a prop rather than creating a duplicate.
* **Shadcn First:** Always compose interfaces using Shadcn primitives.
* **Mandatory Wrappers (Do NOT build raw Modals or Pages):**
    * **Forms/Modals** → Must use `<FormSheet>` (handles backdrop, animations, close buttons).
    * **Page Views** → Must use `<ViewShell>` (handles headers, breadcrumbs, spacing).
    * **Content Cards** → Must use `<CyberCard>` (handles neon glow/glassmorphism).
    * **Lists** → Must use `<DataList>` (handles virtualized rows).
    * **Filters** → Must use `<FilterBar>` (handles search/date inputs).

## 2. Documentation Synchronization (The "Memory" Law)
* **Docs Location:** All documentation lives in `docs/` folder within this repo.
* **Backend Sync:** If you write SQL or modify Supabase tables, you **MUST** immediately update `docs/02_Backend_Schema.md` to reflect the change.
* **Component Registry:** If you create a new `shared` component, add a brief entry to the 'Component Library' section in `docs/01_Frontend_PWA.md`.
* **Status Update:** If a feature (e.g., "Household > Todo") is completed, mark it as [Done] in `docs/01_Frontend_PWA.md`.

## 3. Session Hand-off Protocol
* **Start of Task:** ALWAYS read these docs to understand current state before coding:
    1. `docs/01_Frontend_PWA.md` - Frontend architecture & components
    2. `docs/02_Backend_Schema.md` - Database schema & Supabase
    3. `docs/03_ViewEngine_Sandbox.md` - ViewEngine development (if working on variants)
* **End of Task:** Before finishing, verify that the documentation matches the code you just wrote. This ensures the next agent doesn't hallucinate missing features.
* **ViewEngine Tasks:** If creating/modifying variants, update variant docs in `docs/03_ViewEngine_Sandbox.md`.

## 4. Terminal & Environment (PowerShell)
* **Command Separators:** Use `;` to separate commands. NEVER use `&&`.
* **Git Workflow:** `git add -A; git commit -m "Message"; git push`
* **File Write Fix:** If a file appears truncated (missing closing brackets), fix it using: `Set-Location "Adhoc-App/lifeos-pwa"; Add-Content src/path/to/file.tsx "}"`

## 5. Tech Stack Standards
* **State:** TanStack Query (Server State), Zustand (Global UI State).
* **Styling:** Tailwind CSS with CSS variables (Cyberpunk theme: Cyan/Dark).
* **Charts:** Recharts (via Shadcn/UI Charts).
* **Icons:** Lucide-React.

## 6. Hierarchy Queries (ltree)
* **Always use ltree operators** for hierarchy queries on the `resources` table:
    * `<@` (descendant of): `WHERE path <@ 'root.parent_id'` - Get all items in a folder
    * `@>` (ancestor of): `WHERE path @> 'root.child_id'` - Get path to root
    * `~` (regex match): For pattern-based queries
    * `nlevel(path)` - Get depth of a resource
* **Never use recursive CTEs** for tree traversal when ltree is available
* **Path format:** `root.{uuid_with_underscores}.{uuid_with_underscores}...`
    * UUIDs have hyphens replaced with underscores (ltree constraint)
    * Example: `root.a1b2c3d4_e5f6_7890_abcd_ef1234567890`
* **Use `useResourceTree(path)` hook** for fetching entire branches
* **Use `useResources(parentId)` hook** for direct children only

## 7. ViewEngine Development (Unified Node Architecture)

### Current Phase: Dynamic Navigation & Live Integration ✓
The ViewEngine is now **live** and connected to Supabase:
- **Dynamic Navigation:** Apps are now dynamically discovered from `resources` table (Context Roots).
- **System Apps:** Hardcoded apps (Household, Health, etc.) coexist with User Apps.
- **User Apps:** Any folder with `meta_data.is_system_app = true` becomes a top-level App.
- `ViewEnginePane` bridges Supabase → ViewEngine.

### Key Files
* **Docs:** `docs/03_ViewEngine_Sandbox.md` - Full development guide
* **Entry Point:** `src/engine/index.ts` - Public API + `initializeEngine()`
* **Registry:** `src/engine/registry.ts` - Variant → Component mapping
* **Variants:** `src/engine/components/variants/` - ADD NEW VARIANTS HERE
* **Utils:** `src/engine/utils/resourcesToNodeTree.ts` - Flat→Tree transformer
* **Bridge:** `src/panes/ViewEnginePane.tsx` - Supabase → ViewEngine connector + back button integration
* **Launcher:** `src/hooks/useAppLauncher.ts` - App discovery & merging logic
* **Back Button:** `src/hooks/useBackButton.ts` - Global priority-based back handler system

### Data Flow (Live Integration)
```
useAppLauncher() → Merges System Apps + Context Roots
         ↓
App.tsx → Renders <ViewEnginePane context={id} /> for User Apps
         ↓
useContextRoot(context)  →  rootId, rootPath
         ↓
useResourceTree(rootPath)  →  Resource[] (flat)
         ↓
resourcesToNodeTree(resources, rootId)  →  Node (nested tree)
         ↓
<ViewEngine root={nodeTree} />
```

### Node Schema
```typescript
interface Node {
  id: string           // UUID
  type: NodeType       // 'space' | 'container' | 'collection' | 'item'
  variant: string      // Drives rendering: 'list_row', 'grid_card', etc.
  title: string
  metadata: Record<string, unknown>
  children?: Node[]
  relationships?: NodeRelationship[]
}
```

### Creating New Variants
1. Create component in `src/engine/components/variants/MyVariant.tsx`
2. Use `VariantComponentProps` type and context hooks (`useNode`, `useNodeMeta`)
3. Register in `registry.ts` via `registerVariant('my_variant', MyVariant)`
4. Export from `index.ts`
5. Test in Sandbox with matching JSON

### Context Hooks (use inside variants)
* `useNode()` - Get current node, depth, rootId, rootNode, parentId, findNodeById()
* `useNodeMeta<T>(key, default?)` - Type-safe metadata access
* `useChildCount()`, `useHasChildren()`, `useIsRoot()`
* `renderChildren(node, depth, rootId, rootNode)` - Render child nodes

### Data Aggregation Hooks (for Smart Components)
* `useChildAggregation(node, config)` - Aggregate data from node's own children
* `useDataAggregation(node, config)` - Source-agnostic (supports `source_id` for sibling lookups)
* `useSlotBasedAggregation(node, config)` - Reads `source_id` from slot config automatically
* **source_id Pattern:** Charts/Progress cards can aggregate from sibling nodes by setting `"source_id": "<uuid>"` in metadata

---

## 8. Supabase & RLS Development Mode
* **Test User IDs (Hardcoded):**
    * User 1: `11111111-1111-1111-1111-111111111111`
    * User 2: `22222222-2222-2222-2222-222222222222`
* **Dev RLS Bypass:** When creating new tables with RLS, you MUST add a bypass policy to `04_dev_rls_bypass.sql` using this pattern:
    ```sql
    -- Drop production policy
    DROP POLICY IF EXISTS "Policy Name" ON table_name;
    -- Create dev bypass
    CREATE POLICY "Dev Bypass: Allow Test Users" ON table_name
        FOR ALL 
        USING (user_id IN ('11111111-1111-1111-1111-111111111111'::uuid, '22222222-2222-2222-2222-222222222222'::uuid))
        WITH CHECK (user_id IN ('11111111-1111-1111-1111-111111111111'::uuid, '22222222-2222-2222-2222-222222222222'::uuid));
    ```
* **Production Switch:** Before production, delete `04_dev_rls_bypass.sql` and re-run `02_todo_schema.sql` (or equivalent) to restore `auth.uid()` policies.
* **Frontend user_id:** The frontend uses the same hardcoded user IDs (see `src/lib/supabase.ts`). This ensures seamless switch to real auth later.
